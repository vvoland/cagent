<h1>Tool Configuration</h1>
<p class="subtitle">Complete reference for configuring built-in tools, MCP tools, and Docker-based tools.</p>

<h2>Built-in Tools</h2>

<p>Built-in tools are included with cagent and require no external dependencies. Add them to your agent's <code>toolsets</code> list.</p>

<h3>Filesystem</h3>
<p>Read, write, list, search, and navigate files in the working directory.</p>
<pre><code class="language-yaml">toolsets:
  - type: filesystem
    ignore_vcs: false          # Optional: ignore .gitignore files
    post_edit:                 # Optional: run commands after file edits
      - path: "*.go"
        cmd: "gofmt -w ${file}"</code></pre>

<table>
  <thead><tr><th>Operation</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>read_file</code></td><td>Read the complete contents of a file</td></tr>
    <tr><td><code>read_multiple_files</code></td><td>Read several files in one call (more efficient than multiple <code>read_file</code>)</td></tr>
    <tr><td><code>write_file</code></td><td>Create or overwrite a file with new content</td></tr>
    <tr><td><code>edit_file</code></td><td>Make line-based edits (find-and-replace) in an existing file</td></tr>
    <tr><td><code>list_directory</code></td><td>List files and directories at a given path</td></tr>
    <tr><td><code>directory_tree</code></td><td>Recursive tree view of a directory</td></tr>
    <tr><td><code>search_files_content</code></td><td>Search for text or regex patterns across files</td></tr>
  </tbody>
</table>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>ignore_vcs</code></td><td>boolean</td><td><code>false</code></td><td>When <code>true</code>, ignores <code>.gitignore</code> patterns and includes all files</td></tr>
    <tr><td><code>post_edit</code></td><td>array</td><td><code>[]</code></td><td>Commands to run after editing files matching a path pattern</td></tr>
    <tr><td><code>post_edit[].path</code></td><td>string</td><td>‚Äî</td><td>Glob pattern for files (e.g., <code>*.go</code>, <code>src/**/*.ts</code>)</td></tr>
    <tr><td><code>post_edit[].cmd</code></td><td>string</td><td>‚Äî</td><td>Command to run (use <code>${file}</code> for the edited file path)</td></tr>
  </tbody>
</table>

<div class="callout callout-tip">
  <div class="callout-title">üí° Tip</div>
  <p>The filesystem tool resolves paths relative to the working directory. Agents can also use absolute paths.</p>
</div>

<h3>Shell</h3>
<p>Execute arbitrary shell commands. Each call runs in a fresh, isolated shell session ‚Äî no state persists between calls.</p>
<pre><code class="language-yaml">toolsets:
  - type: shell
    env:                        # Optional: environment variables
      MY_VAR: "value"
      PATH: "${PATH}:/custom/bin"</code></pre>

<p>The agent has access to the full system shell and environment variables. Commands have a default 30-second timeout. Requires user confirmation unless <code>--yolo</code> is used.</p>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>env</code></td><td>object</td><td>Environment variables to set for all shell commands</td></tr>
    <tr><td><code>sandbox</code></td><td>object</td><td>Run commands in a Docker container. See <a href="#configuration/sandbox" onclick="event.preventDefault(); navigate('configuration/sandbox')">Sandbox Mode</a>.</td></tr>
  </tbody>
</table>

<h3>Think</h3>
<p>Step-by-step reasoning scratchpad. The agent writes its thoughts without producing visible output ‚Äî ideal for planning, decomposition, and decision-making.</p>
<pre><code class="language-yaml">toolsets:
  - type: think</code></pre>

<p>No configuration options. No side effects. Recommended for all agents ‚Äî adds minimal overhead while improving reasoning quality.</p>

<h3>Todo</h3>
<p>Task list management. Agents can create, update, and track tasks with status (pending, in-progress, completed).</p>
<pre><code class="language-yaml">toolsets:
  - type: todo
    shared: false              # Optional: share todos across agents</code></pre>

<table>
  <thead><tr><th>Operation</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>create_todo</code></td><td>Create a new task</td></tr>
    <tr><td><code>create_todos</code></td><td>Create multiple tasks at once</td></tr>
    <tr><td><code>update_todos</code></td><td>Update status of one or more tasks</td></tr>
    <tr><td><code>list_todos</code></td><td>List all current tasks with their status</td></tr>
  </tbody>
</table>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>shared</code></td><td>boolean</td><td><code>false</code></td><td>When <code>true</code>, todos are shared across all agents in a multi-agent config</td></tr>
  </tbody>
</table>

<h3>Memory</h3>
<p>Persistent key-value storage backed by SQLite. Data survives across sessions, letting agents remember context, user preferences, and past decisions.</p>
<pre><code class="language-yaml">toolsets:
  - type: memory
    path: ./agent_memory.db  # optional: custom database path</code></pre>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>path</code></td><td>string</td><td>automatic</td><td>Path to the SQLite database file. If omitted, uses a default location.</td></tr>
  </tbody>
</table>

<h3>Fetch</h3>
<p>Make HTTP requests to external APIs and web services.</p>
<pre><code class="language-yaml">toolsets:
  - type: fetch
    timeout: 30                # Optional: request timeout in seconds</code></pre>

<p>Supports GET, POST, PUT, DELETE, and other HTTP methods. The agent can set headers, send request bodies, and receive response data. Useful for calling REST APIs, reading web pages, and downloading content.</p>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Default</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>timeout</code></td><td>int</td><td><code>30</code></td><td>Request timeout in seconds</td></tr>
  </tbody>
</table>

<h3>Script</h3>
<p>Define custom shell scripts as named tools. Unlike the generic <code>shell</code> tool, scripts are predefined and can be given descriptive names ‚Äî ideal for exposing safe, well-scoped operations.</p>

<p><strong>Simple format:</strong></p>
<pre><code class="language-yaml">toolsets:
  - type: script
    shell:
      run_tests:
        cmd: task test
        description: Run the project test suite
      lint:
        cmd: task lint
        description: Run the linter
      deploy:
        cmd: ./scripts/deploy.sh ${env}
        description: Deploy to an environment
        args:
          env:
            type: string
            enum: [staging, production]
        required: [env]</code></pre>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>shell.&lt;name&gt;.cmd</code></td><td>string</td><td>Shell command to execute (supports <code>${arg}</code> interpolation)</td></tr>
    <tr><td><code>shell.&lt;name&gt;.description</code></td><td>string</td><td>Description shown to the model</td></tr>
    <tr><td><code>shell.&lt;name&gt;.args</code></td><td>object</td><td>Parameter definitions (JSON Schema properties)</td></tr>
    <tr><td><code>shell.&lt;name&gt;.required</code></td><td>array</td><td>Required parameter names</td></tr>
    <tr><td><code>shell.&lt;name&gt;.env</code></td><td>object</td><td>Environment variables for this script</td></tr>
    <tr><td><code>shell.&lt;name&gt;.working_dir</code></td><td>string</td><td>Working directory for script execution</td></tr>
  </tbody>
</table>

<h3>Transfer Task</h3>
<p>The <code>transfer_task</code> tool is automatically available when an agent has <code>sub_agents</code>. Allows delegating tasks to sub-agents. No configuration needed ‚Äî it's enabled implicitly.</p>

<h3>LSP (Language Server Protocol)</h3>
<p>Connect to language servers for code intelligence: go-to-definition, find references, diagnostics, and more.</p>
<pre><code class="language-yaml">toolsets:
  - type: lsp
    command: gopls
    args: []
    file_types: [".go"]</code></pre>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>command</code></td><td>string</td><td>LSP server executable command</td></tr>
    <tr><td><code>args</code></td><td>array</td><td>Command-line arguments for the LSP server</td></tr>
    <tr><td><code>env</code></td><td>object</td><td>Environment variables for the LSP process</td></tr>
    <tr><td><code>file_types</code></td><td>array</td><td>File extensions this LSP handles</td></tr>
  </tbody>
</table>

<p>See <a href="#tools/lsp" onclick="event.preventDefault(); navigate('tools/lsp')">LSP Tool</a> for full documentation.</p>

<h3>User Prompt</h3>
<p>Ask users questions and collect interactive input during agent execution.</p>
<pre><code class="language-yaml">toolsets:
  - type: user_prompt</code></pre>

<p>The agent can use this tool to ask questions, present choices, or collect information from the user. Supports JSON Schema for structured input validation.</p>

<p>See <a href="#tools/user-prompt" onclick="event.preventDefault(); navigate('tools/user-prompt')">User Prompt Tool</a> for full documentation.</p>

<h3>API</h3>
<p>Create custom tools that call HTTP APIs without writing code.</p>
<pre><code class="language-yaml">toolsets:
  - type: api
    name: get_weather
    method: GET
    endpoint: "https://api.weather.example/v1/current?city=${city}"
    instruction: Get current weather for a city
    args:
      city:
        type: string
        description: City name
    required: ["city"]
    headers:
      Authorization: "Bearer ${env.WEATHER_API_KEY}"</code></pre>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>name</code></td><td>string</td><td>Tool name</td></tr>
    <tr><td><code>method</code></td><td>string</td><td>HTTP method: <code>GET</code> or <code>POST</code></td></tr>
    <tr><td><code>endpoint</code></td><td>string</td><td>URL with <code>${param}</code> interpolation</td></tr>
    <tr><td><code>args</code></td><td>object</td><td>Parameter definitions</td></tr>
    <tr><td><code>required</code></td><td>array</td><td>Required parameter names</td></tr>
    <tr><td><code>headers</code></td><td>object</td><td>HTTP headers (supports <code>${env.VAR}</code>)</td></tr>
  </tbody>
</table>

<p>See <a href="#tools/api" onclick="event.preventDefault(); navigate('tools/api')">API Tool</a> for full documentation.</p>

<h3>Handoff</h3>
<p>Delegate tasks to remote agents via the A2A (Agent-to-Agent) protocol.</p>
<pre><code class="language-yaml">toolsets:
  - type: handoff
    name: research_agent
    description: Specialized research agent
    url: "http://localhost:8080/a2a"
    timeout: 5m</code></pre>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>name</code></td><td>string</td><td>Tool name for delegation</td></tr>
    <tr><td><code>description</code></td><td>string</td><td>Description for the agent</td></tr>
    <tr><td><code>url</code></td><td>string</td><td>A2A server endpoint URL</td></tr>
    <tr><td><code>timeout</code></td><td>string</td><td>Request timeout (default: 5m)</td></tr>
  </tbody>
</table>

<p>See <a href="#features/a2a" onclick="event.preventDefault(); navigate('features/a2a')">A2A Protocol</a> for full documentation.</p>

<h3>A2A (Agent-to-Agent)</h3>
<p>Connect to remote agents via the A2A protocol. Similar to handoff but configured as a toolset.</p>
<pre><code class="language-yaml">toolsets:
  - type: a2a
    name: research_agent
    url: "http://localhost:8080/a2a"</code></pre>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>name</code></td><td>string</td><td>Tool name for the remote agent</td></tr>
    <tr><td><code>url</code></td><td>string</td><td>A2A server endpoint URL</td></tr>
  </tbody>
</table>

<p>See <a href="#features/a2a" onclick="event.preventDefault(); navigate('features/a2a')">A2A Protocol</a> for full documentation.</p>

<h2>MCP Tools</h2>

<p>Extend agents with external tools via the <a href="https://modelcontextprotocol.io/" target="_blank" rel="noopener noreferrer">Model Context Protocol</a>.</p>

<h3>Docker MCP (Recommended)</h3>

<p>Run MCP servers as secure Docker containers via the <a href="https://github.com/docker/mcp-gateway" target="_blank" rel="noopener noreferrer">MCP Gateway</a>:</p>

<pre><code class="language-yaml">toolsets:
  - type: mcp
    ref: docker:duckduckgo          # web search
  - type: mcp
    ref: docker:github-official     # GitHub integration
  - type: mcp
    ref: docker:fetch               # HTTP fetching</code></pre>

<p>Browse available tools at the <a href="https://hub.docker.com/search?q=&type=mcp" target="_blank" rel="noopener noreferrer">Docker MCP Catalog</a>.</p>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>ref</code></td><td>string</td><td>Docker MCP reference (<code>docker:name</code>)</td></tr>
    <tr><td><code>tools</code></td><td>array</td><td>Optional: only expose these tools</td></tr>
    <tr><td><code>instruction</code></td><td>string</td><td>Custom instructions injected into the agent's context</td></tr>
    <tr><td><code>config</code></td><td>any</td><td>MCP server-specific configuration (passed during initialization)</td></tr>
  </tbody>
</table>

<h3>Local MCP (stdio)</h3>

<p>Run MCP servers as local processes communicating over stdin/stdout:</p>

<pre><code class="language-yaml">toolsets:
  - type: mcp
    command: python
    args: ["-m", "mcp_server"]
    tools: ["search", "fetch"]  # optional: whitelist specific tools
    env:
      - "API_KEY=value"
    env_file:
      - .env</code></pre>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>command</code></td><td>string</td><td>Command to execute the MCP server</td></tr>
    <tr><td><code>args</code></td><td>array</td><td>Command arguments</td></tr>
    <tr><td><code>tools</code></td><td>array</td><td>Optional: only expose these tools</td></tr>
    <tr><td><code>env</code></td><td>array</td><td>Environment variables (<code>"KEY=value"</code> format)</td></tr>
    <tr><td><code>env_file</code></td><td>array</td><td>Files to load environment variables from</td></tr>
    <tr><td><code>instruction</code></td><td>string</td><td>Custom instructions injected into the agent's context</td></tr>
  </tbody>
</table>

<h3>Remote MCP (SSE / Streamable HTTP)</h3>

<p>Connect to MCP servers over the network:</p>

<pre><code class="language-yaml">toolsets:
  - type: mcp
    remote:
      url: "https://mcp-server.example.com"
      transport_type: "sse"         # sse or streamable
      headers:
        Authorization: "Bearer your-token"
    tools: ["search_web", "fetch_url"]</code></pre>

<table>
  <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
  <tbody>
    <tr><td><code>remote.url</code></td><td>string</td><td>Base URL of the MCP server</td></tr>
    <tr><td><code>remote.transport_type</code></td><td>string</td><td><code>sse</code> or <code>streamable</code></td></tr>
    <tr><td><code>remote.headers</code></td><td>object</td><td>HTTP headers (typically for auth)</td></tr>
  </tbody>
</table>

<h2>Tool Filtering</h2>

<p>MCP servers often expose many tools. Use the <code>tools</code> property to whitelist only the ones your agent needs:</p>

<pre><code class="language-yaml">toolsets:
  - type: mcp
    ref: docker:github-official
    tools: ["list_issues", "create_issue", "get_pull_request"]</code></pre>

<div class="callout callout-tip">
  <div class="callout-title">üí° Tip</div>
  <p>Filtering tools improves agent performance ‚Äî fewer tools means less confusion for the model about which tool to use.</p>
</div>

<h2>Tool Instructions</h2>

<p>Add context-specific instructions that get injected when a toolset is loaded:</p>

<pre><code class="language-yaml">toolsets:
  - type: mcp
    ref: docker:github-official
    instruction: |
      Use these tools to manage GitHub issues.
      Always check for existing issues before creating new ones.
      Label new issues with 'triage' by default.</code></pre>

<h2>Combined Example</h2>

<pre><code class="language-yaml">agents:
  root:
    model: anthropic/claude-sonnet-4-0
    description: Full-featured developer assistant
    instruction: You are an expert developer.
    toolsets:
      # Built-in tools
      - type: filesystem
      - type: shell
      - type: think
      - type: todo
      - type: memory
        path: ./dev.db
      - type: user_prompt
      # LSP for code intelligence
      - type: lsp
        command: gopls
        file_types: [".go"]
      # Custom scripts
      - type: script
        run_tests:
          description: Run the test suite
          cmd: task test
        lint:
          description: Run the linter
          cmd: task lint
      # Custom API tool
      - type: api
        name: get_status
        method: GET
        endpoint: "https://api.example.com/status"
        instruction: Check service health
      # Docker MCP tools
      - type: mcp
        ref: docker:github-official
        tools: ["list_issues", "create_issue"]
      - type: mcp
        ref: docker:duckduckgo
      # Remote MCP
      - type: mcp
        remote:
          url: "https://internal-api.example.com/mcp"
          transport_type: "sse"
          headers:
            Authorization: "Bearer ${INTERNAL_TOKEN}"</code></pre>

<div class="callout callout-warning">
  <div class="callout-title">‚ö†Ô∏è Toolset Order Matters</div>
  <p>If multiple toolsets provide a tool with the same name, the first one wins. Order your toolsets intentionally.</p>
</div>
